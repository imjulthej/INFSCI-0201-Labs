	Refactoring my original program from object-oriented programming to functional programming changed the way I thought about how the program was structured. In the original OOP version, I designed the program around a central StyleChecker class that maintained internal state. Each method in the class updated part of a shared report dictionary, and everything was performed through instance methods. This structure allowed me to capture related behavior, but it also made testing and reusability more challenging.

	The functional version then required a complete change in how I approached the code. I had to make sure that all functions were pure since they did not modify external state and always returned new data based on their inputs. I broke the program into smaller, independent functions which each performed a single task and returned new data structures. All data used inside of the functions was treated as immutable, and rather than modifying a shared report, they would return their own result and everything would be brought together to generate the full report file.

	One of the biggest differences I had to take between the two styles was thinking about data flow instead of object behavior. I focused on changing the input data through pure functions instead of managing internal state across methods. This had a few benefits, mainly making the code easier to test and more modular. However, it also required more attention on the return values and made certain things like tracking parent/child AST nodes harder without relying on mutable attributes.